# Dharma（达摩）: 债务发行代币化的通用协议

版本 2.0

Nadav Hollander -- nadav@dharma.io

斯坦福大学2017级计算机学士


## 摘要
达摩是一个区块链协议，可以在其具有高度通用性的架构中，实现去中心化的发起，承销，发行和管理代币化的债务资产。该协议旨在建立一个通用的信息界面，交易所，经纪商和交易商可以通过该界面合理定价代币化债务的违约风险，而无需依赖单一的中心化数据经纪人。达摩协议债券发行计划利用了两种角色在不同的市场竞争以补偿费用 - 承销商和中介机构。前者是可信发起人和债务人违约风险的评估人，后者以无需信赖的方式促进债务融资和发行债务。两者都可以根据历史资产表现进行实证评估，因此，市场有清晰的信号来评估任何特定承销商或中介机构所断言的代币化债务的违约风险。达摩协议的债务发行全过程只需要一个链上交易即可，该协议受到了0x协议很大的启发。


## 引言

> 声明：区块链的一个未被充分认识的优势是，它们必然会导致对代币化资产类别的通用的、无需许可的标准的创建。

就在本文撰写之时，代币众筹模式仅在2017年就筹集了超过20亿美元。如果这证明了什么的话，那就是市场对众筹类产品的需求明显得不到满足，这类产品对散户投资者来说具有类似股票[^1]()的风险特质。然而，股权众筹机制早在“ICO”就出现了——那么，如何解释这种市场对于ICO突然爆发的兴趣呢？如果股权众筹在技术上是可行的，而且已经实际运行很多年了，那么从技术的角度来看，以太坊构建的代币销售生态在哪些方面是独一无二的呢？我认为答案是很简单的：ERC20代币标准创建了共轨，在该共轨上可以以无需许可的和可互操作的方式构建多样化的虚拟代币二级市场生态体系。仅从投资流动性的角度来判断，代币众筹已是对股权融资现状的逐步改善。<sup>[译1](#t-1)</sup>

但在现有的金融体系中，与在债务融资领域“老大哥”相比，股权融资中筹集的资金总额微不足道。然而，债务市场仍然是不透明且专有的；在公开发行或私人投资者中进行债务融资，就像执行股权融资一样，是定制而低效的。这引发我们的思考：为什么不将代币众筹的模式应用于债务融资？


举一个简单的例子，一个公司其实可以发行债券作为一种“债务ICO”，并将代表债券所有权的ERC20代币通过众筹的方式出售。这样看来，一个债务资产可以由无需许可、通用的代币标准来代表的世界，从流动性和透明度的角度来看，将会是一种超越现状的逐步改善。为了让相应的二级市场出现，投资者需要一种标准化的定价机制来计算债务资产的价格。类似于股票的代币价值与品牌协议、项目或底层实体绑定在一起，而类似于债务的代币则在价值上与通常是匿名的对手方的历史财务活动相关联。ERC20标准没有涵盖债务资产的强制性语义，因为它没有提供一种方法以支持:

* 提取机器可读的特定于债务的元数据(如本金、利率等)。
* 从债务资产的条款中提取债务人和债权人之间的偿付历史。
* 将违约风险纳入债务资产的价值中。

达摩协议旨在填补这一空白，并提供一种无需许可的、通用的机制。通过这种机制，各种类型的债务资产可以被发行、出售、管理和定价，而不必依赖任何一种中心化的数据经纪人。

## 架构
达摩协议定义了一种通过一套智能合约、监护人市场和下面将详细阐述的标准化接口来发行、资助、管理和交易债务资产的程序。受到0x去中心化交易协议[^2]()的启发。我们将采用0x的广播订单信息接口（Broadcast Order Messages）作为达摩系统中与之地位类似的达摩债务订单（Dharma Debt Orders）的蓝图，这一机制将在本文中被进一步明确。该协议旨在支持EVM区块链，但也可以扩展为支持任何带有智能合约功能的区块链。首先，我们对文中会出现的一些术语进行解释。

### Agents·代理
我们将**代理**定义为协议的最终使用者——即寻求借入或借出加密货币的实体。这些实体，不管是人、公司、合同还是自动机，都可以毫不意外地分为两类:
- 债务人：债务交易中借用资产的一方，并欠债权人某一约定的价值。
- 债权人：债务交易中借出资产的一方，债务人欠其某一约定的价值。


### Keeper Marketplaces·监护人市场
我们采用了一个包罗万象的术语“监护人”[^3]()，来囊括那些为网络提供增值服务并在各自的市场上竞争以获取手续费的服务提供商。

![不同代理与监护人的交互流程图](https://s3-us-west-2.amazonaws.com/dharma-assets/WhitepaperV2Architecture.png)

#### 1. Underwriters·承销商[^4]()
在传统的债务市场中，承销商是通过管理公共发行的债务和定价借款人违约风险而收取费用的实体。在达摩协议中，这个定义被扩展和形式化为：一个受到信任的实体，它为履行以下职能收取由市场确定的费用:
- 帮助借款人起草债务订单
- 与潜在债务人确定并协商债务条款(即期限、利息、摊销)
- 加密地记录其将某项具体债务关系断定为违约的可能性(此流程将在下文规范中具体描述)
- 管理债务订单的资金，并将其转寄给任何数量的中继节点
- 偿还债务，即在承销商的合理能力下，尽一切所能确保按协议条款及时还款
- 在违约或拖欠情况下，通过法律机制收集抵押品(若债务被担保)或个人资产，并将所得收益转给债权人

这其实与大多数在线贷款机构在日常承销和偿还业务中所做的事情并无二致。我们相信达摩协议将为那些有抱负的在线借贷平台提供另一种更廉价的途径，来促进他们的业务，并获得类似的利润。他们将成为承销商，这样一来就不再需要担心资产负债表风险。同时也避免了开展业务之前，从传统投资者那里筹集必要的债务工具，所带来的时间和资本成本。

> 例：Alice对于如何为ZCash矿工提供发起、承销和偿还贷款有一些新颖的想法，这些旷工往往需要大量的前期资金来购买大量的GPUs。Alice没有去找传统固定收益投资者，而是决定成为一名达摩协议的承销商。她设法获得了必要的贷款从业执照，建立了一个为矿工提供广告服务的网站，并在ZCash社区为她的信贷产品大肆宣传。当借款人来到她的网站时，他们的信用度会被Alice的商用技术自动评分，他们会按照Alice的要求给出贷款条款。在接受了条款之后，Alice加密的断言借款人违约的可能性，将已签署的债务订单转发给了一个中继者，并在贷款的总资金上收取了她想要的费用。整个资金的流动是透明的，可审计的，而爱丽丝在偿还债务方面的能力也可以根据其过往的历史记录来确定。

#### 2. Relayers·中继节点
达摩协议的中继节点与0x协议的中继节点会执行类似的功能：中继节点聚合已签名的债务订单消息，以获得事先约定的费用。它将信息集中在一个集中的订单簿上，并为散户投资者提供投资于其所要求的债务订单的能力。值得注意的是，与0x的中继机制类似，达摩协议的中继节点无需持有任何代币——它们只是提供了一个机制，让债权人可以浏览聚合起来的已被签名的债务订单消息。债权人可以使用该机制来无需信任地发行自己的债务代币，并通过客户端合约的交互给出被请求的本金，(该机制将在本文后面具体介绍)。达摩协议和0x协议的中继节点之间的主要区别是：
- 达摩协议的中继节点不托管二级市场的订单薄，而是托管尚未发行的债务请求的订单薄。
- 达摩协议的中继节点为债权人提供了与债务订单消息及其附带的承销商相关的元数据，这样他们就可以对给定的债务订单的风险状况作出知情的投资决策。
- 达摩协议的中继节点不允许匿名地在订单簿上发布已签名的债务订单。并且他们会审慎地只接受已知的、可信的承保人提交的债务订单。

> 例：Bob希望建立一个零售贷款投资者的门户，用户可以通过该门户投资各种债务资产。可以将其理解为p2p贷款的携程网。Bob通过建立一个在线订单簿，建立了一个零售投资平台，允许投资者浏览债务请求，并审查有关债务人的信用分数和承销商的身份数据，从而成为了达摩协议的中继节点。Bob基于其看到的Alice之前为资产背书的历史表现与她的预测一致，并且知道Alice的公司是一个受公众信任和受监管的实体，Bob允许Alice在他的订单薄上广播已签名的债务订单。当一个债务订单在他的平台上成交时，Bob就收到该订单中所规定的手续费。

## 智能合约

达摩协议利用了几个部署在以太坊网络上的智能合约，这里介绍其中几个与理解协议机制特别相关的合约。

### 1. Debt Kernel · 债务核心合约
债务内核是一个简单的智能合约，它管理所有与铸造非同质化（non-fungible）债务代币相关的业务逻辑，维护债务代币与其相关的债务条款合约之间的映射，将还款从债务人转移到债权人，并将相关的手续费发送给承保人和中继者。这些机制在介绍债务生命周期的上下文中更容易定义，在下面的规范中将得到广泛的阐述。

### 2. Terms Contract · 债务条款合约
债务条款合约是以太坊上的智能合约，是债务人和债权人就共同的、确定的偿还条款达成一致的手段。通过拓展，合约将暴露出一种标准的方式来登记债务人的还款，并可以通过程序在贷款期限内和还款之后查询贷款的偿还情况。一个条款合约可以被用于任何符合其还款条件的债务协议——例如，一个定义了简单的复合利息偿还计划的条款合约可以由任意数量的债务人和债权人承担。下面的规范中将具体定义该接口。

> 注：承诺贷款条件的另一种方案是在对记录在链上的文本形式的贷款条款（即”Ricardian合约“ [^5]()）进行承诺，然后在链下对债务人的申请进行评估。出于若干原因，我们有意选择不推行这种方案。首先，明确定义债务条款的通用模式可以在协议中限制债务资产类型的范围，而通用的协议接口则为无限的债务条款合约打开了大门。此外，在链上通过智能合约来承诺条款将消除对贷款还款状态的评估的任何不确定性——合约是一个单一的、程序化的、不可变的事实来源，它是由契约和客户端查询的。最后，拥有一个在链上的还款状态数据源，将大大简化担保债务协议的实现，使得当违约情况发生时有效地使用担保来进行偿付。

### 3. Repayment Router · 偿还路由合约
偿还路由合约的建立是为了无需信任地将还款从债务人转移到债权人(即债务代币的所有者)。此外，偿还路由合约还可作为一个可信的Oracle，向与债务协议相关联的债务条款合约报告每一笔还款的具体细节。这使债务条款合约可作为一个可信赖的接口来确定债务的违约状态。


## 规范

### 概述
当向债务核心合约提交一份已签名的债务订单信息时，整个债务发行过程将同步地发生在一个链上交易中。如果消息符合下面的规范定义，那么在这个交易中会发生以下过程：
- 债务人对所选择的条款的遵守承诺和保险人对违约可能性的预测将被记录到链上
- 一枚非同质化、不可分割的债务代币，将被铸造给债权人，该代币将与上述承诺相映射
- 本金（扣除费用后）从债权人转移到债务人，任何监护者的费用也将从债权人处扣除，并分发给相应的角色

整个过程如下所示。首先，我们在协议中定义了数据包的格式。

### 报文类型

在协议中，不同的代理和监护人之间的通信，是由我们称为债务订单（Debt Orders）的数据包组成的。

#### Debt Orders·债务订单

债务订单是由中继节点列出的数据包，它们是达摩协议的基本元素：向债务内核提交有效的债务订单，可以触发债务代币的发行，并与所请求的本金金额进行交换。达摩协议不限制债权人、债务人、承销商和转让人之间相互沟通和转让债务订单的方式，债务订单最多可以有3个ECDSA签名：债务人的签名、债权人的签字和承销商的签名。

他们需要签名的具体数据，取决于他们在整个交易中所扮演的角色：债务人和债权人被要求签署债务订单的哈希(即债务订单哈希)，而承销商只需要在债务订单中签署部分数据，我们称之为承销商承诺（underwriter commitment）。

此外，并非所有3个签名都必须附在债务订单上，才能提交给债务内核：如果一个代理或监护人没有参与交易(即债务订单中他们的地址为空)，或者他们参与了交易，但同时也是提交债务订单到债务内核合同的一方，那么他们的签名就不是必须的。

债务订单由下列字段组成:

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`kernelVersion` | 内核版本 | `address` | 债务核心合同的地址。协议升级时，这个地址将被更新。
`issuanceVersion` | 发行版本 | `address` | 与此发行承诺相关的偿还路由合约的地址。
`principalAmount` | 本金数量 | `uint256` | 债务人请求的本金数量。
`principalToken` | 本金代币类型 | `address` | 本金代币的ERC20合约地址。
`debtor` | 债务人 | `address` | 请求借贷的债务人地址
`debtorFee` | 债务人应付手续费 | `uint256` | 将从债务人的本金中扣除的总手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`creditorFee` | 债权人应付手续费 | `uint256` | 债权人在本金基础上需支付的额外手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`relayer` | 中继节点 | `address` | 挂单了本债务订单的中继节点地址
`relayerFee` | 中继节点应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付中继节点的手续费。
`underwriter`| 承销商地址 | `address` | 为该债务资产评级的承销商的地址。
`underwriterFee` | 承销商应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付承销商的手续费。
`underwriterRiskRating` | 承销商给出的风险评级 | `uint32` | 承销商给出的债务人对单位价值债务的平均偿还可能性的量化评估。必须介于0和1之间，编码为一个无符号整数，表示有9位小数（也就是说，50%的可能性将被表示为500000000）
`termsContract` | 条款合约 | `address` | 条款合约的地址，该合约定义了债务还款的条款细则。
`termsContractParameters` | 条款合约参数 | `bytes32` | 条款合同中与偿还条款相关的具体参数（如本金、利率等）。
`expirationTimestamp` | 过期时间 | `uint256` | 在这个时间点后若还未成交，该订单即过期
`salt` | 盐（混淆参数）| `uint` | 伪随机的混淆参数用来区分那些具有同样参数的不同订单的哈希值

#### Debt Issuance Commitments · 债务发行承诺
债务发行承诺是我们单独考虑的债务订单数据包的一个子集，以便为任何给定的债务协议定义一个规范的、唯一的标识符。债务发行承诺表达了债务人(和承销商)想要铸造一枚非同质性的债务代币，在这种情况下，债务代币将不可修改地与元组`(TC, P)`相关联，`TC`是一个已部署的条款合约的地址，该合约遵守了条款合约接口(见下文)，`P`代表了在`TC`合约中所使用的一组参数。此外，承销商承诺一个值`R`，代表承销商对债务人将按照`(TC, P)`所定义的任何给定的单位价值进行偿付的平均可能性的评估。该子集数据包的哈希被称为**发行哈希**，它在整个协议中被用作债务协议的规范唯一标识符。

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`issuanceVersion` | 发行版本 | `address` | 与此发行承诺相关的偿还路由合约的地址。
`debtor` | 债务人 | `address` | 请求借贷的债务人地址
`underwriter`| 承销商地址 | `address` | 为该债务资产评级的承销商的地址。
`underwriterRiskRating` | 承销商给出的风险评级 | `uint32` | 承销商给出的债务人对单位价值债务的平均偿还可能性的量化评估。必须介于0和1之间，编码为一个无符号整数，表示有9位小数（也就是说，50%的可能性将被表示为500000000）
`termsContract` | 条款合约 | `address` | 条款合约的地址，该合约定义了债务还款的条款细则。
`termsContractParameters` | 条款合约参数 | `bytes32` | 条款合同中与偿还条款相关的具体参数（如本金、利率等）。
`salt` | 盐（混淆参数）| `uint` | 伪随机的混淆参数用来区分那些具有同样参数的不同订单的哈希值

#### Debtor/Creditor Commitment Hash · 债务人/债权人承诺哈希
债务人/债权人承诺哈希是有债务人或债权人签名的有效载荷，以表明他同意该债务订单上的参数。它由以下债务订单参数子集的Keccak256哈希组成:

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`kernelVersion` | 内核版本 | `address` | 债务核心合同的地址。协议升级时，这个地址将被更新。
`issuanceHash` | 发行哈希 | `bytes32` | 上面描述的债务发行承诺的哈希值，作为债务协议的通用标识符。
`principalAmount` | 本金数量 | `uint256` | 债务人请求的本金数量。
`principalToken` | 本金代币类型 | `address` | 本金代币的ERC20合约地址。
`debtorFee` | 债务人应付手续费 | `uint256` | 将从债务人的本金中扣除的总手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`creditorFee` | 债权人应付手续费 | `uint256` | 债权人在本金基础上需支付的额外手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`relayer` | 中继节点 | `address` | 挂单了本债务订单的中继节点地址
`relayerFee` | 中继节点应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付中继节点的手续费。
`underwriterFee` | 承销商应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付承销商的手续费。
`expirationTimestamp` | 过期时间 | `uint256` | 在这个时间点后若还未成交，该订单即过期

#### Underwriter Commitment Hash · 承销商承诺哈希
承销商承诺哈希是承销商签名的有效载荷，以表明他同意债务订单上的参数。承销商需要为一个不同的参数子集签名，使得债务人不需要向每个为他们广播其债务订单的中继节点申请新的签名。我们将在下面进一步阐述。

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`kernelVersion` | 内核版本 | `address` | 债务核心合同的地址。协议升级时，这个地址将被更新。
`issuanceHash` | 发行哈希 | `bytes32` | 上面描述的债务发行承诺的哈希值，作为债务协议的通用标识符。
`principalAmount` | 本金数量 | `uint256` | 债务人请求的本金数量。
`principalToken` | 本金代币类型 | `address` | 本金代币的ERC20合约地址。
`underwriterFee` | 承销商应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付承销商的手续费。
`expirationTimestamp` | 过期时间 | `uint256` | 在这个时间点后若还未成交，该订单即过期


综上所述，如果以下签名均已附上，则该债务订单被认为已准备好提交:
1. 债务人对债务人/债权人承诺哈希的ECDSA签名。(除非向达摩智能合约提交订单的地址为该债务人)
2. 承销商对承销商承诺哈希的ECDSA签名。(如果没有承销商，或向达摩智能合约提交订单的地址为该承销商，可以省略该签名)
3. 债权人对债务人/债权人承诺哈希的ECDSA签名。(除非向达摩智能合约提交订单的地址为该债权人)


### 债务发行流程
任何拥有有效的债务订单，并附带必要的附加签名的人，都可将该订单提交至达摩智能合约。将债务订单提交到达摩智能合约后，一个债务协议代币将被铸造并与本金同步交换。我们将债务人完成的债务订单称为“债务人完成的订单提交”（Debtor-Filler Order Submissions），并将债权人完成的债务订单称为“债权人完成的订单提交”（Creditor-Filler Order Submissions）。


#### 债权人完成的订单提交
![](https://s3-us-west-2.amazonaws.com/dharma-assets/Creditor-Filler+2.png)

以下步骤与上图中的圈中数字相对应:

1. 债务人向承销商申请贷款。
2. 在债务人、承销商和中继节点间将发生债务订单握手（下文将详细描述），完成后中继节点挂出一个有效的、完整的债务订单。
3. 债权人对中继节点维护的公共订单薄上的债务订单进行评估。
4. 如果债权人想要完成订单，他首先会授权代币转让代理（token transfer proxy）可以转让大于等于本金加上债权人费用的代币（即使用ERC20的`approve`函数）。请注意，此步骤不必在债权人填写的每一个订单中重复，债权人可以向代币转移代理进行一次授权，使该代理有权限转移很大数量的代币。智能合约将保证只有当他通过提交或为一份债务订单提供签名的时候，合约才会从他的帐户中取出相应的代币。
5. 然后债权人将其直接提交给债务核心合约。请注意，在这一步中不需要他的签名，因为他向内核提交的订单就已经暗示了他同意其参数。
6. 债务核心接着向债权人发放一个非同质性、不可分割的令牌，代表债务人对合同和相关参数的承诺。
7. 债务内核将数量为`本金-债务人手续费`的贷款转入债务人账户。
8. 债务内核将定义在债务订单中的承销商手续费转入承销商账户。
9. 债务内核将定义在债务订单中的中继节点手续费转入中继节点账户。

债务人创建订单的情形，对有许多潜在债权人而且债务人对最终获得贷款的时间没有太多要求的情况有利。

#### 债务人完成的订单提交

![](https://s3-us-west-2.amazonaws.com/dharma-assets/Debtor-Filler+2.png)

以下步骤与上图中的圈中数字相对应:
1. 债务人向承销商申请贷款。
2. 在债务人、承销商和中继节点间将发生债务订单握手（下文将详细描述），完成后中继节点挂出一个有效的、完整的债务订单。
3. 债权人对中继节点维护的公共订单薄上的债务订单进行评估。
4. 如果债权人想要完成订单，他首先会授权代币转让代理（token transfer proxy）可以转让大于等于本金加上债权人费用的代币（即使用ERC20的`approve`函数）。然后，在债务订单的债务/债权人承诺协议里附上其ECDSA签名。
5. 债权人将已签署的债务订单提交给中继节点。
6. 中继节点将已签署的债务订单转发给债务人。
7. 债务人在方便的时候将签署的债务订单提交给债务内核，这将发行一个独特的、非同质性债务订单代币给债权人，使其成为债务订单的最终签字人。
8. 债务内核将数量为`本金-债务人手续费`的贷款转入债务人账户。
9. 债务内核将定义在债务订单中的承销商手续费转入承销商账户。
10. 债务内核将定义在债务订单中的中继节点手续费转入中继节点账户。


债务人完成方案对于债务人希望同步地借用代币，并且每一笔交易可以是一系列更复杂交易中的一部分，这样的场景是有利的。例如，如果一个智能合约要求用户支付一定数量用于存储的代币(如FileCoin、Storj等)，为了使用它，用户可以通过上述方案获得一个有效的、已签名的债务订单来作为智能合约函数调用的一个参数。然后，智能合约可以将债务人的订单提交给债务内核，同时向债务人提供必要的存储代币，然后在同一笔交易中将其记入智能合约。这大大减少了在几乎任何情况下信用借贷情景里执行交易的摩擦成本。

#### Debt Order Handshake · 债务订单握手流程
上面提到的债务订单握手流程被正式地定义如下：
![](https://s3-us-west-2.amazonaws.com/dharma-assets/DebtOrderHandshake-DebtorMaker.png)

1. 债务人从指定的承销商处请求其承销的债务，列举他想要的贷款条件（即本金类型、期限等）。
2. 承销商使用专有风险模型评估债务人的违约风险，构建承销商承诺(同时需要构建债务发行承诺)，将其ECDSA签名附到承销商承诺的哈希上，并将债务发行承诺、承销商承诺和ECDSA签名发送给债务人。
3. 如果参数符合债务人的期望条件，债务人现在便拥有了所有必要的参数来构建一个完整的债务订单。但如果他希望将订单转给潜在的债权人，债务人将需要一个中继节点（主要是该节点的费用计划和地址）。
4. 中继节点以他的费用计划和地址回应债务人的请求。
5. 如果中继节点的费用符合债务人的意愿，债务人将使用承销商和中继节点提供的参数构建一个完整的债务订单，并将订单发送给中继节点。
6. 中继者在他们的订单簿上列出完整的债务订单。他们挂出订单就已默认表明其接受订单上的所有参数，故其签名不是必要的。

#### Debt Repayment Process · 债务偿还流程
为了使任何债务资产的偿还状况都能得到实证评估，我们定义了一个偿还流程，在偿还流程中，还款是由偿还路由合同引导完成，整个过程将不可修改地记录在链上。

当债务人希望偿还债务时，他们将执行以下操作:
1. 债务人向代币转让代理授予转让限额(即通过ERC20 `approve` 函数)，其数额大于或等于所期望的偿还金额。
2. 债务人将一个交易发送到还款路由合约，并附带上参数确定的所需还款金额。然后，还款路由合约将获取该债务的当前受益人的地址(即债务代币的持有者)，将所期望的还款金额从债务人的帐户转移到受益人的帐户上，并调用债务的条款合同中的 `registerRepayment` 方法登记该笔还款。

注意：我们可以构建一个简单得多的方案，在这个方案中，债务人直接向债权人偿还债务，而不需要利用债务内核合约。然而，实际上有必要让对于债务内核介入到偿还过程中，以确保当一笔还款在给定的条款合同中登记时，有一笔还款交易与之对应。

### Terms Contract Interface · 条款合约接口
我们要求通过达摩协议所发行的任何债券都承诺签订一份“智能合约”，即条款合约。条款合约的作用是提供一个不可变的、程序化的、可证明的可信来源，来揭示债务的偿还状态。这使我们能够以经验和明确的方式在债务发行过程中定义还款计划，并在债务的生命周期中对债务的偿还状况进行评估。所需要的功能接口如下：

```
/// 条款合约接口
interface TermsContract {
     /// 登记债务人的偿还交易，并附带上一些元信息，如对美元汇率等。
     /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
     /// @param  payer address. The address of the payer.
     /// @param  beneficiary address. The address of the payment's beneficiary.
     /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.
     /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.
    function registerRepayment(
        bytes32 agreementId,
        address payer,
        address beneficiary,
        uint256 unitsOfRepayment,
        address tokenAddress
    ) public returns (bool _success);

    /// 一个registerRepayment的变种，将还款信息记录在NFT代币中。
    /// to determine ex post facto the value repaid (e.g. current USD
    /// exchange rate)
    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
    /// @param  payer address. The address of the payer.
    /// @param  beneficiary address. The address of the payment's beneficiary.
    /// @param  tokenId The tokenId of the NFT transferred in the repayment transaction
    /// @param  tokenAddress The address of the token with which the repayment transaction was executed.
    function registerNFTRepayment(
        bytes32 agreementId,
        address payer,
        address beneficiary,
        uint256 tokenId,
        address tokenAddress
    ) public returns (bool _success);

     /// 返回到特定区块高度时，累计需要偿还的价值单位。
     /// 注意这不是一个常量函数，函数的返回值对于给定的区块高度也可能发生改变，因为利率可能会在交易几方间被重新协调。
     /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
     /// @param  blockNumber uint. The block number for which repayment expectation is being queried.
     /// @return uint256 The cumulative units-of-value expected to be repaid by the time the given blockNumber lapses.
    function getExpectedRepaymentValue(
        bytes32 agreementId,
        uint256 blockNumber
    ) public view returns (uint256);

     /// 返回到特定区块高度时，累计已偿还的价值单位。
     /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
     /// @param blockNumber uint. The block number for which repayment value is being queried.
     /// @return uint256 The cumulative units-of-value repaid by the time the given blockNumber lapsed.
    function getValueRepaid(
        bytes32 agreementId,
        uint256 blockNumber
    ) public view returns (uint256);
}
```

请注意，在`getExpectedRepaymentValue`和`getValueRepaid`函数中，还款数量被抽象地定义为了“价值单位”。
我们有意地没有定义偿还债务的单位，这使得债券发行人有了更多的灵活性。比如说，在执行代币的实际交易时，可以用法定货币来表示预期的偿还价值。


### 违约和收债
达摩协议对承销商处理违约的手段和回收债务的方式不加限制。很容易想到的是，承销商可以通过利用法院来发行具有法律约束力的链下借贷协议，并通过借助法律来收回债务。当然也可以使用链上担保机制，利用某一特定债务的承诺条款合约所提供的功能，一旦当前价值偿还能力低于预期价值的偿还能力，就立即去中心化地向债权人发放抵押品。

无数其他的方案可以被用来抑制违约，达摩协议不会提倡或设计任何特定的解决方案，而是旨在提供一种标准机制，通过这种机制来研究承销商对于债务资产的评级历史，以评估承销商的表现。市场应该倾向于奖励那些过去表现强劲的承销商，反之亦然。承销商过去绩效的衡量标准，我们称之为`F_β`，它借鉴了统计分析中二元分类器的评估函数，目的是为了评估承销商对违约预测的准确性：

- 定义：`x` ∈ 1,...,n 是承销商评级的债务
- 定义：`α_x` 是债务`x`合约到期时，债务人期望偿还的总价值。
- 定义：`γ_x` 是债务`x`合约到期时，债务人实际偿还的总价值。
- 定义：`δ_x` 是在承销商的预测中，债务`x`违约的可能性。
- 定义：`β`为调整召回率对准确性重要程度的超参数。

```
p=∑{x}min(α_x−γ_x,δ_x*α_x)/∑{x}δ_x*α_x 
r=∑xmin(α_x−γ_x,δ_x*α_x)/∑_x(α_x−γ_x) 
F_β=(1+β^2)*p*r/β^2*p+r 
```

需要重点强调，这不是一个对承销商的表现进行评估时完全可靠且无所不包的度量指标。恶意欺诈的承销商可以通过各种方式(参见"攻击"小节)来博弈该指标。更确切地说，这是一个经验信号，善意的、可信的承销商可以被透明地评估。当市场上的承销商都值得信赖时，该指标将是一个非常有价值的信号。


# 使用案例
债务是一种非常多样化的资产类别，理论上，几乎任何类型的债务协议都可以通过达摩协议来发行和承销。
从事任何类型法币借贷业务的在线放贷机构，都可以将他们的后台迁移到达摩协议上。他们只需在每一笔发出的交易中同时扮演债务人和承销商的角色，将本金支付转化为收据上的法币,并确保所有借款人支付和偿还均使用法币，这样便可以对用户完全隐藏那些贷款流程链上部分的复杂细节。
我们认为，这最终将为寻求债务资本的在线贷款机构提供一个有吸引力的替代途径。


然而，在短期内，链上债务发行的更有说服力的使用场景将是那些仅能在链上实现或因为使用了区块链而使用体验得到大大提高的场景。下面我们将重点介绍其中的几个:

## 首次债券发行/代币化SAFTs
做一个ICO是一项需要非常多资源的努力，这个领域的项目开始不断增加其preICO轮的募资数额以服务其最终的ICO轮。这促成了SAFT[^6]()的诞生：SAFT是一种类似于可转换债务协议的法律工具。表明投资者出资X美元，在未来的一笔交易中，它希望以折扣价获得价值X美元的代币。

通过达摩协议，可以签发一种基于密码学协议的preICO融资条款，从使用条款的角度来看，操作起来将比现有的私募轮更灵活。

在最简单的例子中，债务条款合同可以规定一种类似于SAFT的普通折扣预售协议。贷款的本金是X美元，预期的还款是价值X美元的最终以折扣价出售的效用代币。因此，投资者将得到一种可转换债券，表明他们在最终的效用代币中有折价所有权。

当合同条款可以对各种各样的投资者补偿方案进行编码时，这些安排将变得更加有用和有趣。举个例子，债务人在最终ICO时，其募集资金的90%使用以太币以Y%的利率偿还，剩下的10%以有折扣的效用代币支付。这类似于传统金融体系中的风险债务融资，并将给投资者提供一个风险的下限(即，90%的X美元押注于ICO的成功)，而收益潜力也随之降低(即X美元的10%将押注于该效用代币的最终市场需求)。这可以通过创建一份合约来进一步增强，该合约作为合约的若干个见证者之一，在最终的ICO中收取收益，将收益作为抵押，直到债务条款合同表明预售投资者得到了适当的补偿。更多的预售方案可以使用债务条款合同在达摩协议中实现（例如，根据债务人完成最终ICO的时间，提供不同的折扣方案。或如果一个ICO未能成功募集到目标资金，返还投资人资金的方案等等）。

## 去中心化的杠杆借贷

依赖于链下订单薄（如0x协议）的去中心化交易所是代币生态系统中重要而必要的基础设施。
然而，如果他们想要在实用性和用户体验方面与中心化的交易所竞争，他们需要以某种形式支持保证金交易。
我们可以通过在达摩协议中发放保证金贷款来构建一个去中心化的借贷系统，并将合同上的条款与指定的债务作为一种闸门函数（gating function），允许代理人在必要的时候将锁定在智能合约中的保证金平仓。
在这样的方案中，承销商将要求债务人根据预期的保证金比率将抵押品锁定到保证金账户合约中，作为对借款人的债务发行承诺进行证明和评级的先决条件。
然后，债务人将在一笔保证金交易中同步地完成债务订单和0x的广播订单（Broadcast Order），收款账户为被锁定的保证金账户。
持仓期间，承销人将为对条款合同提供可信的价格指数参考。
债务人有权利关闭帐户，直到合同条款表明出现了以下两种情况：

1. 保证金帐户处于违约状态(按约定的保证金比率)
2. 仓位已经过期

此时合同保证金帐户将赋予债权人关闭账户和获得她想要利息的权利。

基于上述讨论，我们可以利用该协议建立一个保证金贷款系统，该系统可以在现有的去中心化交易所中与很自然的与各类中继节点提供的订单簿集成。

# 攻击和局限性
## 欺诈的承销商
以欺诈方式运作的承销商可以欺骗投资者，让他们相信提供出来的债务主要来自借款人，但他们自己实际上就是借款人。
可以想象，一个欺诈性的承销商可以用许多水军的公钥贷款给自己，并以此来建立一个极其优质的评级表现历史。然后通过欺骗债权人来投资他们的债务订单，在最后来一票大的：他们是真正的借方，并且完全拖欠债务。
正是出于这个原因，我们强调，达摩并不是一个完全无需信任的协议——在这个方案，借贷和放贷只有在承销商是已知的、可信的而不仅是一个匿名公钥的情况下才安全。
所以，尽可能建立债权人对自己的信任是承销商的责任。为了实现这一点，承销商既可以通过依托已有的公开确定的身份实体的信誉(例如，债务人是一个企业或公司)，或通过培育公开可信并且已知的与监管机构关系(例如， 当承销商是现有的在线贷款提供商)。
承销商必须与投资方建立某种信任，这与一个协议的开发团队进行一轮募资的过程是一样的。两者都在促成公共投资项目的发行，因此，双方都有维护自己合法性和正直性的责任。


## 虚假身份攻击（Sybil Attacks）
在贷款协议的背景下，虚假身份攻击指使用大量的欺诈身份，同时承担多个无担保债务，并且一次性违约，几乎没有任何后果。
在很大程度上，防御虚假身份攻击是承销商的职责——如果承销商的KYC程序不够强大，不足以检测欺诈身份的行为，这会反映在他们过往的评级表现中。
然而，虚假身份攻击者可能会在一段时间内从几个承销商那里同时请求债务，这意味着在类似借贷领域的承销商之间的数据共享很可能会成为重要的需求。

## 债权人恶意破坏（Debtor Griefing）
对于在交易中债权人扮演债务订单提供者的场景，债权人显然可以实施我们称之为“债务人恶意破坏”的攻击中。在债务人即将完成订单时，提前将锁定在合约中本金提走。
为了执行攻击，债权人将在握手过程中作为订单提供方，协助提交一笔债务订单，等待债务人的完成交易，通过侦听当地的以太坊节点的待定交易池，在同一个区块中提交交易，将他的代币从本金代币所在的账户移出，从而导致债务人的交易失败并抛出异常。
这样的攻击会导致债务人完成订单的交易抛出异常，并使得债务人浪费少量以太币。
在简单的一次性交易情景中，最坏的情况就是浪费以太币。
然而，对有组织地攻击的情况，债权人显然可以使用这种机制来对一个中继节点的整个订单簿进行拒绝服务的攻击，因为他是一个做市商（订单提交者），利用连续生成的地址，在订单簿中，不断地对债务订单进行处理，不断地对债务人进行诈骗，并将回笼的资金用于进一步的恶意攻击。
大规模实施此类攻击的以太币成本是不可忽视的，但是，假设攻击者的动机是来自中继节点对于其他中继节点的某种敲诈勒索，那么如果攻击者拥有必要的流动性，攻击就会被证明是有利可图的。
防范此类攻击的最佳防线是中继节点自己——受到此类攻击的中继节点有各种各样的选择可以缓和恶意债权人的拒绝服务攻击，从简单的IP封锁，到更激进的政策如要求债权人通过KYC流程。

## 私下交易

我们把“私下交易”指的是在任何一笔债务交易中，代理人试图避免向参与构建交易的监护人支付相关费用。
考虑以下例子，一个第三方维护的在线列表，潜在债务人自愿把他们的公钥和他们的邮箱地址相关联。
债权人可以在浏览器上查看中继节点订单簿上的债务订单，通过比对订单薄上的公钥，债权人可以利用第三方的在线列表来与债务人进行沟通。
然后，债权人和债务人可以在另一个渠道上沟通，建立一个点对点的债务订单，在这种订单中，承销商和中继节点都不能收到手续费，从而节省了相关的费用。

承销商对这种脆弱性可能不那么敏感，因为债权人在整个债务期限内都要依赖他们的服务。
然而对于中继节点来说，债权人进行此类攻击时并不会有任何损失。这意味着，一个对手通过构建一个公共可用的匹配引擎来系统性地破坏一个中继节点的操作是可行的，它可以从中继者的订单簿中获取债务订单，并匹配参与的债务人和债权人，这样他们就可以构建一个交易。

我们认为，在实际情况下，系统性的参与私下交易撮合具有相当高的摩擦成本。假设该交易撮合能成功，需要求代理商参与另一个债务订单握手，在高度异步的条件下，这可能会耗费大量的时间才能节省相关的费用。
但即便我们构建了一个可以使用的没有摩擦成本的私下交易机制，中继节点也不是就没有办法了。
一个特别有针对性的中继节点可以通过一个“提交-执行”二步结构来混淆债务人的地址，而这一结构可以保留中继节点与债权人之间的信任关系[^7]():

1. 在既定的列出债务订单的方式之外，中继节点可以列出被修改过的债务订单，其中所有包含债务人地址的字段都会被隐藏，包括相关的信息及其签名。仅提供能让债权人决定是否要放贷的足够信息。
2. 提交：债权人通过向一个特制的中继智能合约提交无效和不完整的债务订单来，承诺会完成订单。此外，债权人授予该智能合约以一定数额的授信来最终完成该订单[^8]()。
3. 执行：中继节点通过提交完整的、有效的债务订单来执行上述合约的发行和交换。然后，该合约验证所提交的债务订单中的所有字段与债权人提交的、不完整的债务订单(除了包含债务人地址的字段外)对应的所有字段，然后依次从债权人转移其所需的本金代币，以其作为中间债权人的身份向债务核心合约提交完整的债务订单，并最终将其新拥有的非同质化债务代币转让给债权人。如果提交的债务订单无效或与债权人承诺的债务订单不匹配，则合同抛出异常，债权人继续持有其债务代币。

因此，如果情况需要，中继节点可以利用上面的“提交-执行”结构来给债权人以信任的方式来完成被混淆过的债务订单。


# 脚注

1. 这里强调的是“类似股票”的，在理论上，协议代币不是股权，但是，就他们的风险概况和他们所吸引的投机兴趣的类别而言，其表现出来的行为就像股票一样。 ↩
2. Warren, Will, and Amir Bandeali. “0x: An Open Protocol for Decentralized Exchange on the Ethereum Blockchain.” https://0xproject.Com, 0xproject.com/pdfs/0x_white_paper.pdf. ↩
3. Zurrer, Ryan. “Keepers - Workers That Maintain Blockchain Networks.” Medium, Medium, 5 Aug. 2017, medium.com/@rzurrer/keepers-workers-that-maintain-blockchain-networks-a40182615b66. ↩
4. 在早先版本的白皮书中，我们将这些实体称作”风险评估者“，或者简写成”RAA“。这个版本中，我们去掉了这些术语，转向选用更容易理解的表达方式：承销商。 ↩
5. Grigg, Ian. “The Ricardian Contract.” Iang.org, 2000, iang.org/papers/ricardian_contract.html ↩
6. Batiz-Benet, Juan, et al. “The SAFT Project: Toward a Compliant Token Sale Framework.” saftproject.com/static/SAFT-Project-Whitepaper.pdf. ↩
7. 注意这种构建仅限于债务人构建的债务订单。 ↩
8. 通过ERC20的`approve`方法。 ↩



<a name="t-1">step-function improvement</a>: http://www.businessinsider.com/step-function-growth-2010-12/?IR=T



